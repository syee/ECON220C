clear;
clc;
N = 500;
T = 5;
beta = 1;
nreplic = 1000;

beta_hat = zeros(nreplic,1);

%This is allowing for possible serial correlation
sigma_beta_hat =  zeros(nreplic,1);
%This is saying serial correlation is 0
sigma_beta_tilde =  zeros(nreplic,1);

for replic = 1:1:nreplic;
    
    %Create matrix of x values distributed standard normal into a T x N
    %matrix
    X = randn (T,N);
    %sigma = repmat(sqrt(T)*mean(x),T,1);
    %variance covariance matrix for u_{it}
    sigma = abs(X);
    E = sigma.*randn(T,N);
    Y = X + E;
    
    %mean averages over each column. This gives us the average value for
    %each individual. 
    
    %This is the demeaning
    Y = Y - repmat(mean(Y),T,1);
    E = E - repmat(mean(E),T,1);
    X = X - repmat(mean(X),T,1);
    
    yy = Y';  % N x T
    xx = X';  % N x T
    ee = E';
    
    xx = xx(:); % vectorize x' 
    yy = yy(:); % vectorize y'
    ee = ee(:);

    %beta_hat is like the beta from the pooled OLS
    beta_hat(replic) = xx\yy;  %fixed effects estimator
    %Equivalent method of calculating beta with pooled OLS
    
    beta_hat_molly = beta + sum(X.^2, 'all').^ -1 .*  sum(X.*E, 'all');

    beta_hat_beta = beta + (sum(sum(X.^2,2),1)).^(-1) * sum(sum(X.*E,2),1);
    
%     beta_hat = xx\yy;
    
    beta_hat_ali = beta + norm(X,'fro')^(-2) *sum(sum((X).*(E)));
    
    ourBeta = beta + (sum(xx.^2).^-1) * sum(xx.*ee);
    
    % This is the demeaned error terms because it comes from the demeaned X
    % and Y
    e_hat = Y - X*beta_hat(replic);  % residual from fixed effect regression
                                     % T x N
    % equation 3
    sigma_beta_hat(replic) = sqrt((xx'*xx)^(-2)*sum(sum(X.*e_hat).^2));
    % equation 4
    sigma_beta_tilde(replic) = sqrt((xx'*xx)^(-2)*sum(sum((X.^2).*(e_hat.^2))));
end

%1a
% figure(10)
% hist(beta_hat);
% 
% figure(1)
% hist(sigma_beta_hat);
% 
% figure(2)
% hist(sigma_beta_tilde);

%1b
true_sigma = std(beta_hat);

%1c
sigma_hat = mean(sigma_beta_hat);
sigma_tilde = mean(sigma_beta_tilde);
std_sigma_hat = std(sigma_beta_hat);
std_sigma_tilde = std(sigma_beta_tilde);



bias_hat = sigma_hat - true_sigma;
bias_tilde = sigma_tilde - true_sigma;
display('Bias Hat: %d ', num2str(bias_hat));
display(bias_hat);
fprintf("Bias tilde: ", string(bias_tilde));
rmse_sigma_hat = sqrt((sigma_hat-true_sigma)^2 + std_sigma_hat^2);
rmse_sigma_tilde = sqrt((sigma_tilde-true_sigma)^2 + std_sigma_tilde^2);

%Based on RMSE criterion, sigma_hat is better than sigma_tilde. Which
%suggests there is some serial dependence in our data.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem 1d T = 10
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

N = 500;
T = 10;
beta = 1;
nreplic = 1000;

beta_hat = zeros(nreplic,1);

%This is allowing for possible serial correlation
sigma_beta_hat =  zeros(nreplic,1);
%This is saying serial correlation is 0
sigma_beta_tilde =  zeros(nreplic,1);

for replic = 1:1:nreplic;
    
    %Create matrix of x values distributed standard normal into a T x N
    %matrix
    X = randn (T,N);
    %sigma = repmat(sqrt(T)*mean(x),T,1);
    %variance covariance matrix for u_{it}
    sigma = abs(X);
    E = sigma.*randn(T,N);
    Y = X + E;
    
    %mean averages over each column. This gives us the average value for
    %each individual. 
    
    %This is the demeaning
    Y = Y - repmat(mean(Y),T,1);
    E = E - repmat(mean(E),T,1);
    X = X - repmat(mean(X),T,1);
    
    yy = Y';  % N x T
    xx = X';  % N x T
    ee = E';
    
    xx = xx(:); % vectorize x' 
    yy = yy(:); % vectorize y'
    ee = ee(:);

    %beta_hat is like the beta from the pooled OLS
    beta_hat(replic) = xx\yy;  %fixed effects estimator
    %Equivalent method of calculating beta with pooled OLS
    
    beta_hat_molly = beta + sum(X.^2, 'all').^ -1 .*  sum(X.*E, 'all');

    beta_hat_beta = beta + (sum(sum(X.^2,2),1)).^(-1) * sum(sum(X.*E,2),1);
    
%     beta_hat = xx\yy;
    
    beta_hat_ali = beta + norm(X,'fro')^(-2) *sum(sum((X).*(E)));
    
    ourBeta = beta + (sum(xx.^2).^-1) * sum(xx.*ee);
    
    e_hat = Y - X*beta_hat(replic);  % residual from fixed effect regression
                                     % T x N
    % equation 3
    sigma_beta_hat(replic) = sqrt((xx'*xx)^(-2)*sum(sum(X.*e_hat).^2));
    % equation 4
    sigma_beta_tilde(replic) = sqrt((xx'*xx)^(-2)*sum(sum((X.^2).*(e_hat.^2))));
end

%1d_a
% figure(10)
% hist(beta_hat);
% 
% figure(1)
% hist(sigma_beta_hat);
% 
% figure(2)
% hist(sigma_beta_tilde);

%1d_b
true_sigma = std(beta_hat);

%1d_c
sigma_hat = mean(sigma_beta_hat);
sigma_tilde = mean(sigma_beta_tilde);
std_sigma_hat = std(sigma_beta_hat);
std_sigma_tilde = std(sigma_beta_tilde);
bias_hat = sigma_hat - true_sigma;
bias_tilde = sigma_tilde - true_sigma;
rmse_sigma_hat10 = sqrt((sigma_hat-true_sigma)^2 + std_sigma_hat^2);
rmse_sigma_tilde10 = sqrt((sigma_tilde-true_sigma)^2 + std_sigma_tilde^2);

%Based on RMSE criterion, sigma_hat is better than sigma_tilde. Which
%suggests there is some serial dependence in our data.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem 1d T = 20
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

N = 500;
T = 20;
beta = 1;
nreplic = 1000;

beta_hat = zeros(nreplic,1);

%This is allowing for possible serial correlation
sigma_beta_hat =  zeros(nreplic,1);
%This is saying serial correlation is 0
sigma_beta_tilde =  zeros(nreplic,1);

for replic = 1:1:nreplic;
    
    %Create matrix of x values distributed standard normal into a T x N
    %matrix
    X = randn (T,N);
    %sigma = repmat(sqrt(T)*mean(x),T,1);
    %variance covariance matrix for u_{it}
    sigma = abs(X);
    E = sigma.*randn(T,N);
    Y = X + E;
    
    %mean averages over each column. This gives us the average value for
    %each individual. 
    
    %This is the demeaning
    Y = Y - repmat(mean(Y),T,1);
    E = E - repmat(mean(E),T,1);
    X = X - repmat(mean(X),T,1);
    
    yy = Y';  % N x T
    xx = X';  % N x T
    ee = E';
    
    xx = xx(:); % vectorize x' 
    yy = yy(:); % vectorize y'
    ee = ee(:);

    %beta_hat is like the beta from the pooled OLS
    beta_hat(replic) = xx\yy;  %fixed effects estimator
    %Equivalent method of calculating beta with pooled OLS
    
    beta_hat_molly = beta + sum(X.^2, 'all').^ -1 .*  sum(X.*E, 'all');

    beta_hat_beta = beta + (sum(sum(X.^2,2),1)).^(-1) * sum(sum(X.*E,2),1);
    
%     beta_hat = xx\yy;
    
    beta_hat_ali = beta + norm(X,'fro')^(-2) *sum(sum((X).*(E)));
    
    ourBeta = beta + (sum(xx.^2).^-1) * sum(xx.*ee);
    
    e_hat = Y - X*beta_hat(replic);  % residual from fixed effect regression
                                     % T x N
    % equation 3
    sigma_beta_hat(replic) = sqrt((xx'*xx)^(-2)*sum(sum(X.*e_hat).^2));
    % equation 4
    sigma_beta_tilde(replic) = sqrt((xx'*xx)^(-2)*sum(sum((X.^2).*(e_hat.^2))));
end

%1d_a
% figure(10)
% hist(beta_hat);
% 
% figure(1)
% hist(sigma_beta_hat);
% 
% figure(2)
% hist(sigma_beta_tilde);

%1d_b
true_sigma = std(beta_hat);

%1d_c
sigma_hat = mean(sigma_beta_hat);
sigma_tilde = mean(sigma_beta_tilde);
std_sigma_hat = std(sigma_beta_hat);
std_sigma_tilde = std(sigma_beta_tilde);
bias_hat = sigma_hat - true_sigma;
bias_tilde = sigma_tilde - true_sigma;
rmse_sigma_hat20 = sqrt((sigma_hat-true_sigma)^2 + std_sigma_hat^2);
rmse_sigma_tilde20 = sqrt((sigma_tilde-true_sigma)^2 + std_sigma_tilde^2);

%Based on RMSE criterion, sigma_hat is better than sigma_tilde. Which
%suggests there is some serial dependence in our data.

















% 
% [std(beta_hat) mean(sigma_beta_hat) mean(sigma_beta_tilde) std(sigma_beta_hat), std(sigma_beta_tilde)...
%     sqrt((mean(sigma_beta_hat)-std(beta_hat))^2 +std(sigma_beta_hat)^2), sqrt((mean(sigma_beta_tilde)-std(beta_hat))^2 +std(sigma_beta_tilde)^2)]
% 
%     
% 
